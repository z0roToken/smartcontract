// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title ZERO Token (ZRO)
 * @notice This smart contract is part of an experimental tokenomics model
 *         designed to make it easier to distribute tokens directly and fairly.
 *
 * @dev ZERO (ZRO) Tokenomics:
 *      - 30% FREE distribution via 0 BNB transaction (airdrop)
 *      - 50% PUBLIC sale via >= 0.001 BNB
 *      - 20% CREATOR supply claimable after 30 days or full distribution
 *
 * The goal is to create an initial token distribution that is transparent,
 * community-first, and avoids presale, whitelisting, or centralized control.
 *
 * Created by: ZeroLabs
 * Twitter/X: zer0_token
 * Telegram: https://t.me/zer0_token
 * Year: 2025
 */

abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }
}

abstract contract Ownable is Context {
    address private _owner;
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    constructor(address initialOwner) {
        _transferOwnership(initialOwner);
    }
    function owner() public view virtual returns (address) {
        return _owner;
    }
    modifier onlyOwner() {
        require(owner() == _msgSender(), "Ownable: caller is not the owner");
        _;
    }
    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), "Ownable: new owner is the zero address");
        _transferOwnership(newOwner);
    }
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

interface IERC20Metadata is IERC20 {
    function name() external view returns (string memory);
    function symbol() external view returns (string memory);
    function decimals() external view returns (uint8);
}

contract ERC20 is Context, IERC20, IERC20Metadata {
    mapping(address => uint256) private _balances;
    mapping(address => mapping(address => uint256)) private _allowances;
    uint256 private _totalSupply;
    string private _name;
    string private _symbol;
    constructor(string memory name_, string memory symbol_) {
        _name = name_;
        _symbol = symbol_;
    }
    function name() public view virtual override returns (string memory) {
        return _name;
    }
    function symbol() public view virtual override returns (string memory) {
        return _symbol;
    }
    function decimals() public view virtual override returns (uint8) {
        return 18;
    }
    function totalSupply() public view virtual override returns (uint256) {
        return _totalSupply;
    }
    function balanceOf(address account) public view virtual override returns (uint256) {
        return _balances[account];
    }
    function transfer(address to, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _transfer(owner, to, amount);
        return true;
    }
    function allowance(address owner, address spender) public view virtual override returns (uint256) {
        return _allowances[owner][spender];
    }
    function approve(address spender, uint256 amount) public virtual override returns (bool) {
        address owner = _msgSender();
        _approve(owner, spender, amount);
        return true;
    }
    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
        address spender = _msgSender();
        _spendAllowance(from, spender, amount);
        _transfer(from, to, amount);
        return true;
    }
    function _transfer(address from, address to, uint256 amount) internal virtual {
        require(from != address(0), "ERC20: transfer from zero");
        require(to != address(0), "ERC20: transfer to zero");
        uint256 fromBalance = _balances[from];
        require(fromBalance >= amount, "ERC20: transfer > balance");
        unchecked {
            _balances[from] = fromBalance - amount;
        }
        _balances[to] += amount;
        emit Transfer(from, to, amount);
    }
    function _mint(address account, uint256 amount) internal virtual {
        require(account != address(0), "ERC20: mint to zero");
        _totalSupply += amount;
        _balances[account] += amount;
        emit Transfer(address(0), account, amount);
    }
    function _approve(address owner, address spender, uint256 amount) internal virtual {
        require(owner != address(0), "ERC20: approve from zero");
        require(spender != address(0), "ERC20: approve to zero");
        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
        uint256 current = allowance(owner, spender);
        if (current != type(uint256).max) {
            require(current >= amount, "ERC20: insufficient allowance");
            unchecked {
                _approve(owner, spender, current - amount);
            }
        }
    }
}

contract ZeroToken is ERC20, Ownable {
    uint256 public constant TOTAL_SUPPLY = 1_000_000_000 * 1e18;
    uint256 public constant AIRDROP_SUPPLY = 300_000_000 * 1e18;
    uint256 public constant PUBLIC_SUPPLY = 500_000_000 * 1e18;
    uint256 public constant CREATOR_SUPPLY = 200_000_000 * 1e18;

    uint256 public constant AIRDROP_REWARD = 1_000 * 1e18;
    uint256 public constant RATE = 10_000 * 1e18;
    uint256 public constant UNIT_PRICE = 0.001 ether;

    uint256 public airdropped;
    uint256 public sold;

    mapping(address => bool) public hasClaimed;

    uint256 public launchTime;
    bool public creatorClaimed;

    address public immutable vault;

    constructor() ERC20("ZERO", "ZRO") Ownable(msg.sender) {
        launchTime = block.timestamp;
        vault = 0xEA606a8D4D003E587037563a15c77CEF170bB041;
    }

    receive() external payable {
        _process(msg.sender, msg.value);
    }

    fallback() external payable {
        _process(msg.sender, msg.value);
    }

    function _process(address user, uint256 amount) internal {
        if (amount == 0) {
            require(!hasClaimed[user], "Already claimed airdrop");
            require(airdropped + AIRDROP_REWARD <= AIRDROP_SUPPLY, "Airdrop supply exhausted");

            hasClaimed[user] = true;
            airdropped += AIRDROP_REWARD;
            _mint(user, AIRDROP_REWARD);
        } else if (amount >= UNIT_PRICE) {
            uint256 units = amount / UNIT_PRICE;
            uint256 tokensToSend = units * RATE;
            uint256 usedBNB = units * UNIT_PRICE;
            uint256 refund = amount - usedBNB;

            require(sold + tokensToSend <= PUBLIC_SUPPLY, "Public supply exhausted");

            sold += tokensToSend;
            _mint(user, tokensToSend);

            (bool sentVault, ) = vault.call{value: usedBNB}("");
            require(sentVault, "BNB transfer to vault failed");

            if (refund > 0) {
                (bool refunded, ) = payable(user).call{value: refund}("");
                require(refunded, "Refund failed");
            }
        } else {
            revert("Send 0 BNB (airdrop) or >= 0.001 BNB (public)");
        }
    }

    function claimCreatorTokens() external onlyOwner {
        require(!creatorClaimed, "Already claimed");
        require(
            block.timestamp >= launchTime + 30 days ||
            (airdropped >= AIRDROP_SUPPLY && sold >= PUBLIC_SUPPLY),
            "Not yet eligible"
        );

        creatorClaimed = true;
        _mint(owner(), CREATOR_SUPPLY);
    }

    function totalDistributed() external view returns (uint256) {
        return airdropped + sold + (creatorClaimed ? CREATOR_SUPPLY : 0);
    }

    function _ZRO_signature_hash() internal pure returns (bytes32) {
        return keccak256("ZRO-by-ZeroLabs-2025");
    }
}
